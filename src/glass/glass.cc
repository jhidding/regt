#include "../base/system.hh"
#include "../base/format.hh"
#include "../base/longstring.hh"
#include "../base/progress.hh"

#include "distances.hh"

#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>

using namespace System;

template <unsigned R>
void make_particle_glass(std::ostream &fo, Header const &H)
{
	typedef mVector<double, R> Point;

	size_t M = static_cast<size_t>(round(pow(2, R*H.get<double>("mbits"))));
	double L = H.get<double>("size");
	size_t seed = H.get<size_t>("seed");

	double frac = H.get<double>("frac");
	unsigned steps = H.get<unsigned>("steps");

	Array<Point> X(M), F(M);
	generate(X, Glass::random_uniform_particles<R>(seed, L));

	double mu, z;
	switch (R)
	{
		case 2: mu = L * pow(1.0 / (2.0 * M_PI * M), 1./2);
			break;

		case 3: mu = L * pow(3.0 / (4.0 * M_PI * M), 1./3);
			break;
	}

	std::cerr << "est. mean particle separation: " << mu << std::endl;

	bool first_iteration = true;
	for (unsigned i = 0; i < steps; ++i)
	{
		double F_sum = 0;
		kdTree::Tree<Point,R> T(X.begin(), X.end(), 
			[] (Point const &p, int i) { return p[i]; });

		if (first_iteration)
		{
			double r = 0, r2 = 0;

			for (size_t p = 0; p < M; ++p)
			{
				Point q = T.nearest_neighbour(Glass::Distance_squared<R>(L, X[p]));
				double d = Glass::dsqr(L, X[p], q);
				r += sqrt(d) / M;
				r2 += d / M;
			}

			std::cerr << "real mean particle separation: " << r << std::endl;
			std::cerr << "sqrt(<r^2> - <r>^2): " << sqrt(r2 - r*r) << std::endl;
		}

		Misc::ProgressBar PB(M, Misc::format("iteration ", i, " ..."));
		for (size_t p = 0; p < M; ++p)
		{
			double a = 0.01, b = 10.0 * mu;

			Glass::Force<R> f(L, X[p]);
			T.traverse(f, Glass::Annulus<R>(L, X[p], a, b));
			F[p] = f.sum(); F_sum += F[p].norm();

			/*
			while (true)
			{
				Glass::Force<R> f(X[p]); Point total = 0;
				T.traverse(f, Glass::Annulus<R>(X[p], a, b));
				total += f.sum();

				if (f.sum().sqr() / total.sqr() < 1e-4)
				{
					F[p] = total;
					F_sum += total.norm();
					break;
				}

				a = b; b += mu;
			}*/

			PB.tic();
		}
		PB.finish(false);

		if (first_iteration)
		{
			z = mu * frac * M / F_sum;
			std::cerr << " z-value: " << z << std::endl;
		}

		if (H.get<bool>("debug"))
		{
			for (size_t p = 0; p < M; ++p)
				std::cout << X[p] << " " << F[p] * z << std::endl;
			std::cout << std::endl << std::endl;
		}

		for (size_t p = 0; p < M; ++p)
		{
			X[p] += F[p] * z;
			X[p] %= L;
		}

		first_iteration = false;

		if (i == steps - 1)
		{
			std::cerr << " -> done\n";
			double r = 0, r2 = 0;

			for (size_t p = 0; p < M; ++p)
			{
				Point q = T.nearest_neighbour(Glass::Distance_squared<R>(L, X[p]));
				double d = Glass::dsqr(L, X[p], q);
				r += sqrt(d) / M;
				r2 += d / M;
			}

			std::cerr << "real mean particle separation: " << r << std::endl;
			std::cerr << "sqrt(<r^2> - <r>^2): " << sqrt(r2 - r*r) << std::endl;
		}
	}


	X.to_file(fo);
}

void cmd_glass(int argc, char **argv)
{
	std::ostringstream ss;
	ss << time(NULL);
	std::string timed_seed = ss.str();

	Argv C = read_arguments(argc, argv,
		Option({0, "h", "help", "false",
			"print help on the use of this program."}),

		Option({Option::VALUED | Option::CHECK, "i", "id", date_string(),
			"identifier for filenames."}),

		Option({Option::VALUED | Option::CHECK, "d", "dim", "3",
			"dimensions of the simulation, either 2 or 3."}),

		Option({Option::VALUED | Option::CHECK, "b", "mbits", "8",
			"2-log of the number of particles N."}),

		Option({Option::VALUED | Option::CHECK, "L", "size", "100.0",
			"physical size of the box in Mpc/h."}),
		
		Option({Option::VALUED | Option::CHECK, "", "seed", timed_seed,
			"random seed."}),
		
		Option({Option::VALUED | Option::CHECK, "", "frac", "0.2",
			"mean step size in units of the mean particle separation, "
			"approximated as L * (3 / 4 pi N)^(1/3). "}),
		
		Option({Option::VALUED | Option::CHECK, "", "steps", "3",
			"number of iterations."}),
		
		Option({0, "", "debug", "false",
			"debug mode: output particles in text format, each iteration."}));

	if (C.get<bool>("help"))
	{
		std::cout << "Cosmic workset Conan, by Johan Hidding.\n\n";
		std::cout << Misc::LongString("Create a glass file: This is a file containing particle "
			"positions that are not on a grid, but more regular than a Poisson "
			"process. This is achieved by running a N-body tree code with repulsive "
			"gravity, starting with a sample of particles generated by a Poisson process. ",
			72, [] () { return " \033[34m|\033[m "; }) << std::endl;
		C.print(std::cout);
		exit(0);
	}

	System::Header 	H; H << C;
	System::History I; I << C;

	std::string fn_output = timed_filename(C["id"], "glass", -1);

	// write headers to file.
	std::ofstream fo;
	fo.open(fn_output.c_str(), std::ios::out | std::ios::binary);
	H.to_file(fo);
	I.to_file(fo);

	// run 2 or 3 dimensional version.
	switch (H.get<unsigned>("dim"))
	{
		case 2: make_particle_glass<2>(fo, H);
			break;

		case 3: make_particle_glass<3>(fo, H);
			break;
	}

	fo.close();
}

Global<Command> _GLASS("glass", cmd_glass);


